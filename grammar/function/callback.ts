//....


// callback
// 콜백 ( call - back ) :  <무엇인가 한다(동사 -> 함수)> 내가 정하고 (정의). -> 이것을 나 아닌 다른 애한테 시킨다.
// -> 무엇인가 한다를 내가 정의 하고 => 함수는 내가 만든다. => 이게 누가 할지는 몰라.
// -> 무엇인가한다(함수)를 하는(함수)를 (실행되지 않은 데이터 덩어리 = 값 = () 나올수가 없어.)  다른애 애를 불러서 시킨다 "() -> 요 표시가 나와야해." .


// 실제 상항
// 콜백이 필요한 상황이 무엇인지 부터  아는게 중요
// 콜백이 존재하는 이유가 있어야 존재 할수 있어
// 우리는 개발에서 존재할 이유가 없으면 존재 하지 않아야 한다.
// 필요없는것은 있을 필요가 없어.
// 있으면 -> 필요한거야


// 콜백함수를 쓰는애가 있어야 콜백이 필요한거야
// 콜백함수가 없다면 -> 쓰는애도 없어야해
// 쓰는애가 필요한다면 콜백이 반드시 있어해
// 쓰는애가 먼저 생겨
// 쓰는애가 왜 콜백이 필요해라는 이유를 알아야해


// 쓰는애는 왜 콜백을 부를까?
// 코딩에 기본
// 1. 내 일을 빠르게 해주니까
// 2. 일을 빠르게 한다
//      1. 일을 적게 하면 (행동 갯수를 줄여)
//      2. 비교적 비슷한 일을 하는 애들을 그룹으로 묶어서 통일된 행동패턴이 보이면 그걸로 일을 통일시켜 관리하고, 그 개수를 통일시킨다. -> 일을 적게한다 -> 일을 빠르게한다.
//      3. 일을 효율적으로 한다는 말은. 내가 할 일의 전체적인 것을 파악하고 그룹화하고 단순화(중복을 없엔다 중복을 1개로 만들고. 그것을 공유한다.)하고 구체적으로 바꾼다  -> 일을 적게해 (이마트 직원 (물건 가져다놓는))


// 코딩에 기본중 ( 중복없이 간결하게 정한다. )
// 중복제거 -> 콜백시스템이 존재하는거야.
// 그룹화 + 자동화(= !!!똑같은 작업!!! 을 따로 정의해서 그것만 불러서 쓴다)


// 방금전에 이마트 직원 (물건 가져다 놓은 일) 을 하는걸 코드
// 워커가 물건을 받아들고 매장에 진열을 하는데.
// 진열하는 칸이 있으면 진열하고 결과값은 true,
// 진열하는 칸이 없어서 진열을 못하면 false

const worker = (goodsNm: string): boolean => {
    const emart = [
        {floor: 3, goods: ["computer", "game", "electronic"]},
        {floor: 2, goods: ["cloth", "sock"]},
        {floor: 1, goods: ["milk", "snack"]},
    ];


    for (let i = 0; i < emart.length; i++) {
        emart[i].goods.map((value) => {
            if (value === goodsNm) {
            }
        })

    }


}

