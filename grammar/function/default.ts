// Part 1 기본
// 함수의 기본 구성
// 1. 입력값 (parameter, argument)
// 2. 행동 ( logic, execute, action )
// 3. 출력값 (return value)

// + 4. 지금 정의 한 함수의 이름, 또는 이름이 없음


// 1. 기본형
function funcNm(param1: string): string {
    return "helloWorld";
}

// 2. 단축형 ( => 화살표 함수. 더 중요한건 함수라는 애를 지칭하는 값으로 존재 )

let nm = "ciao"; // <- nm = string;
let age = 36;   // <- age = number;


// getName = function
// -> 그냥 값 (행동하지 않음)
// 그 값에 (getName)  "()" 붙히면 실행이 됨. -> "()"  안붙히면 그냥 값.
// -> "()" 이름 뒤에 붙는데. 그 이름을 불러서 () 붙히면. 그게 함수이면 실행. 함수가 아니면. 에러
// 객체지향언어 에서 안됨 (특히 자바. 1급 객체가 오브젝트 이기 떄문에 기본단위는 (데이터 또는 객체))
// 함수형 언어 에서는 가능 ( 1급 객체가 함수 이기떄문. (데이터 또는 함수))
let getName = (age: number): string => {
    let nm = "ciao";
    let nm2 = "c" + "i" + "a" + "o";
    return nm2;
}


// Part2 심화
// 함수의 의미
// 함수를 해석 해야 할 떄 상황
// 1. 이미 정의된 함수가 있다. -> 함수가 있다. -> 어디선가 쓰이고 있다. (확실한 참)
//      1. 입력값의 의미 : 필요한 값의 고정 => 파라미터의 종류 및 타입은 바뀌지 않는다. -> 즉. 있는데로 써야 해 + 어디서 이놈이 쓰이는지는 알수가 없다.
//      2. 행동의 의미 : 이 함수가 존재하는 이유 => 이부분만 내가 맘대로 바꿀수 있다. 내가 조작을 할수 있는 부분. 무한으로 뻗어나가는 루트 맘대로 해도되..
//      3. 출력값의 의미 : 필요한 값의 고정 => 리턴 값 종류 및 타입은 바뀌지 않는다. -> 즉. 있는데로 써야 해 + 어디서 이놈이 쓰이는지는 알수가 없다.
//      => 결론 : 입력값, 출력값 만 규칙을 따르면. 이안에 그 무엇이라도 들어갈수 있다.

// 2. 필요에 있어서 함수를 만들어야 한다. -> 함수가 없다
//  -> 필요에 있어서 만들어야함 -> 이미 행동이 무엇인지(필요)가 무엇인지 알고 있는 상태에서 시작
//  -> 행동 (대략적인 입력값과, 정확한 출력값) 대략 정해져있어.
//  -> 출력값은 정해져있어 (거의 고정).
//  -> 입력값( 출력값을 만들려고 함수의 행동을 작성하다가 미처 생각치 못한 값들이 필요해서 추가될수도 있다. 단 이것은 함수를 처음 정의할때 적용되고, 이 함수가 쓰임이 생기면 더이상 바꿀수 없다.)
//      1. 입력값의 의미 :
//      2. 행동의 의미
//      3. 출력값의 의미
